from aiogram import Router
from aiogram.types import (
    Message, CallbackQuery, InputMediaPhoto, InputMediaAudio, 
    InputMediaDocument, InputMediaVideo, ReplyKeyboardRemove
)
from aiogram.fsm.context import FSMContext
from aiogram.filters import StateFilter
from typing import Union, Optional, cast
from .format_event_dates import format_event_dates
import asyncpg
import os
from dotenv import load_dotenv

from bot.keyboards.events.my_events import my_events_keyboard


from bot.states.event_states import EventView
from bot.services.event_service import EventService
from bot.database.user_repo import get_user_by_telegram_id
from bot.keyboards.events import events_list_keyboard
from bot.keyboards.events.manage_event import (
    manage_event_keyboard, 
    manage_event_reply_keyboard,
    
)
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton, ReplyKeyboardRemove

load_dotenv()
DATABASE_URL = os.getenv("DATABASE_URL")

router = Router()

MediaType = InputMediaAudio | InputMediaDocument | InputMediaPhoto | InputMediaVideo


async def show_event_list(
    message_or_callback: Union[Message, CallbackQuery],
    state: FSMContext,
    source: str,
    page: int = 0
):
    message: Optional[Message] = None
    user_id: Optional[int] = None

    if isinstance(message_or_callback, CallbackQuery):
        msg = message_or_callback.message
        if msg is not None and isinstance(msg, Message):
            message = msg
            user = message_or_callback.from_user
            user_id = user.id if user else None
    elif isinstance(message_or_callback, Message):
        message = message_or_callback
        user = message.from_user
        user_id = user.id if user else None

    if message is None or user_id is None:
        return

    conn = await asyncpg.connect(DATABASE_URL)
    event_service = EventService(conn)
    db_user = await get_user_by_telegram_id(conn, user_id)

    if not db_user:
        await conn.close()
        await message.answer("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ —Å–∏—Å—Ç–µ–º–µ.")
        return

    if source == "active":
        events = await event_service.get_active_events(db_user["id"])
        title = "–í–∞—à–∏ –∞–∫—Ç–∏–≤–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è:"
    elif source == "created":
        events = await event_service.get_created_events(db_user["id"])
        title = "–°–æ–∑–¥–∞–Ω–Ω—ã–µ –≤–∞–º–∏ —Å–æ–±—ã—Ç–∏—è:"
    elif source == "archive":
        events = await event_service.get_archive_events(db_user["id"])
        title = "–ê—Ä—Ö–∏–≤–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è:"
    else:
        events = []
        title = "–°–æ–±—ã—Ç–∏—è"

    await conn.close()


    if not events:
        await message.answer("–°–æ–±—ã—Ç–∏–π –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.", reply_markup=my_events_keyboard)
        return

    await state.set_state(EventView.viewing_events)

    if isinstance(message_or_callback, CallbackQuery):
        try:
            await message.delete()
        except Exception:
            pass

    await message.answer(title, reply_markup=events_list_keyboard(events, page, source))


@router.message(StateFilter(EventView.choosing_category), lambda m: m.text == "üìå –ê–∫—Ç–∏–≤–Ω—ã–µ")
async def handle_active_events(message: Message, state: FSMContext):
    await show_event_list(message, state, source="active", page=0)


@router.message(StateFilter(EventView.choosing_category), lambda m: m.text == "üõ† –°–æ–∑–¥–∞–Ω–Ω—ã–µ")
async def handle_created_events(message: Message, state: FSMContext):
    await show_event_list(message, state, source="created", page=0)


@router.message(StateFilter(EventView.choosing_category), lambda m: m.text == "üì¶ –ê—Ä—Ö–∏–≤–Ω—ã–µ")
async def handle_archive_events(message: Message, state: FSMContext):
    await show_event_list(message, state, source="archive", page=0)


@router.callback_query(StateFilter(EventView.viewing_events), lambda c: c.data and c.data.startswith("event:"))
async def handle_show_event(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    msg = callback.message
    if not callback.data or msg is None or not isinstance(msg, Message):
        return

    parts = callback.data.split(":")
    if len(parts) != 4:
        return
    _, event_id, source, page = parts

    conn = await asyncpg.connect(DATABASE_URL)
    event_service = EventService(conn)
    event = await event_service.get_event_by_id(int(event_id))
    await conn.close()

    if not event:
        await msg.answer("–°–æ–±—ã—Ç–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")
        return

    price = "–±–µ—Å–ø–ª–∞—Ç–Ω–æ" if event["price"] == 0 else f"{event['price']}‚ÇΩ"
    caption = (
        f"<b>{event['title']}</b>\n\n"
        f"<i>{event['description']}</i>"
        # f"üìÖ {format_event_dates(event['start_date'], event['end_date'])}\n"
        # f"üë§ –û—Ä–≥–∞–Ω–∏–∑–∞—Ç–æ—Ä: {event['organizers']}\n"
        # f"üí∞ –°—Ç–æ–∏–º–æ—Å—Ç—å: {price}"
    )

    try:
        await msg.delete()
    except Exception:
        pass

    photos = event.get("photos") or []
    if photos:
        media = [InputMediaPhoto(media=photos[0], caption=caption, parse_mode="HTML")]
        media.extend([InputMediaPhoto(media=photo) for photo in photos[1:]])
        await msg.answer_media_group(
            cast(
                list[MediaType],  # aiogram –æ–∂–∏–¥–∞–µ—Ç list[MediaType]
                media
            )
        )
    else:
        await msg.answer(caption, parse_mode="HTML")

    videos = event.get("videos") or []
    for video in videos:
        await msg.answer_video(video)

    from_user = callback.from_user
    user_id = from_user.id if from_user else None

    
    await msg.answer(
        # f"üìÖ {format_event_dates(event['start_date'], event['end_date'])}\n"
        # f"üë§ –û—Ä–≥–∞–Ω–∏–∑–∞—Ç–æ—Ä: {event['organizers']}\n"
        # f"üí∞ –°—Ç–æ–∏–º–æ—Å—Ç—å: {price}",  # –Ω–µ–≤–∏–¥–∏–º—ã–π —Å–∏–º–≤–æ–ª, –Ω–µ –≤—ã–≤–æ–¥–∏—Ç—Å—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
        f"{format_event_dates(event['start_date'], event['end_date'])} ‚Ä¢ {price} ‚Ä¢ {event['organizers']}\n",
        
        reply_markup=manage_event_reply_keyboard()
    )
    await msg.answer(
        "–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Å–æ–±—ã—Ç–∏–µ:",
        reply_markup=manage_event_keyboard(event, user_id, source, page)
    )

    await state.set_state(EventView.viewing_events)
    await state.update_data(event_id=event['id'], source=source, page=page)

# --- –•–µ–Ω–¥–ª–µ—Ä—ã –¥–ª—è reply-–∫–Ω–æ–ø–æ–∫ ---
@router.message(lambda m: m.text == "üì® –†–∞–∑–æ—Å–ª–∞—Ç—å –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è")
async def handle_send_invitations(message: Message, state: FSMContext):
    data = await state.get_data()
    event_id = data.get("event_id")
    if not event_id:
        await message.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Å–æ–±—ã—Ç–∏–µ –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–π.")
        return

    if not message.from_user:
        await message.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è Telegram.")
        return

    telegram_id = message.from_user.id

    conn = await asyncpg.connect(DATABASE_URL)
    user_row = await conn.fetchrow("SELECT id FROM users WHERE telegram_id = $1", telegram_id)
    if not user_row:
        await conn.close()
        await message.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ —Å–∏—Å—Ç–µ–º–µ.")
        return
    user_id = user_row['id']

    event_service = EventService(conn)
    await event_service.invite_all_users(event_id=int(event_id), inviter_user_id=user_id, conn=conn)
    await conn.close()
    await message.answer("‚úÖ –ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º!")


@router.message(lambda m: m.text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥")
async def handle_back(message: Message, state: FSMContext):
    # –í–µ—Ä–Ω—É—Ç—å –∫ —Å–ø–∏—Å–∫—É –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–æ–±—ã—Ç–∏–π, –Ω–∞–ø—Ä–∏–º–µ—Ä
    await message.answer("–í–æ–∑–≤—Ä–∞—â–∞—é –∫ —Å–ø–∏—Å–∫—É —Å–æ–±—ã—Ç–∏–π...", reply_markup=ReplyKeyboardRemove())
    await show_event_list(message, state, source="active", page=0)

@router.message(StateFilter(EventView.viewing_events), lambda m: m.text == "üóë –£–¥–∞–ª–∏—Ç—å")
async def handle_delete_event_reply(message: Message, state: FSMContext):
    print("–£–¥–∞–ª–∏—Ç—å –Ω–∞–∂–∞—Ç–æ!")
    print("STATE:", await state.get_state())

    data = await state.get_data()
    event_id = data.get("event_id")
    if not event_id:
        await message.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Å–æ–±—ã—Ç–∏–µ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.")
        return
    await state.update_data(pending_delete_id=event_id)
    await message.answer(
        "–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å —ç—Ç–æ —Å–æ–±—ã—Ç–∏–µ?\n–í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –±—É–¥–µ—Ç –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ!",
        reply_markup=ReplyKeyboardMarkup(
            keyboard=[
                [KeyboardButton(text="‚úÖ –î–∞"), KeyboardButton(text="‚ùå –ù–µ—Ç")]
            ],
            resize_keyboard=True,
            one_time_keyboard=True
        )
    )

@router.message(lambda m: m.text == "‚úÖ –î–∞")
async def confirm_delete_reply(message: Message, state: FSMContext):
    data = await state.get_data()
    event_id = data.get("pending_delete_id")
    if not event_id:
        await message.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Å–æ–±—ã—Ç–∏–µ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.")
        return
    # –£–¥–∞–ª—è–µ–º –∏–∑ –ë–î
    conn = await asyncpg.connect(DATABASE_URL)
    event_service = EventService(conn)
    await event_service.delete_event_by_id(int(event_id))
    await conn.close()
    await message.answer("–°–æ–±—ã—Ç–∏–µ —É–¥–∞–ª–µ–Ω–æ!\n–í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –µ–≥–æ —É–∂–µ –Ω–µ–ª—å–∑—è.", reply_markup=ReplyKeyboardRemove())
    await state.clear()
    # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –º–µ–Ω—é "–ú–æ–∏ —Å–æ–±—ã—Ç–∏—è"
    await state.set_state(EventView.choosing_category)
    from bot.handlers.events.navigation import show_my_events_menu
    await show_my_events_menu(message, state)

from bot.handlers.events.view import handle_show_event

@router.message(lambda m: m.text == "‚ùå –ù–µ—Ç")
async def cancel_delete_reply(message: Message, state: FSMContext):
    data = await state.get_data()
    event_id = data.get("event_id")
    source = data.get("source", "active")
    page = data.get("page", 0)

    await message.answer("–£–¥–∞–ª–µ–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.")

    # –°–æ–∑–¥–∞—ë–º —Ñ–µ–π–∫–æ–≤—ã–π callback, —á—Ç–æ–±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å handle_show_event –ø–æ–≤—Ç–æ—Ä–Ω–æ
    class FakeCallback:
        def __init__(self, message, data, from_user):
            self.message = message
            self.data = data
            self.from_user = from_user
        async def answer(self, *args, **kwargs): return None

    fake_callback = FakeCallback(
        message=message,
        data=f"event:{event_id}:{source}:{page}",
        from_user=message.from_user
    )
    await handle_show_event(fake_callback, state)

